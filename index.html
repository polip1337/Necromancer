<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Necromancer Ascension</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="container">
    <div id="resource-panel">
      <div id="cog-button">⚙️</div>
      <h3>Resources</h3>
      <div id="resources"></div>
    </div>
    <div id="main-content">
      <div id="info">
        <h2>Necromancer Ascension</h2>
        <p id="loop">Cycle: 1</p>
        <p id="evil">Evil: 0/100</p>
        <p id="infamy">Infamy: 0</p>
        <div id="evil-bar"><div id="evil-progress"></div></div>
        <p id="status">Begin your path to eternal dominion!</p>
      </div>
      <div id="tabs">
        <button id="tab-tasks" class="tab-button active">Tasks</button>
        <button id="tab-paths" class="tab-button">Paths & History</button>
        <button id="tab-combat" class="tab-button">Combat</button>
        <button id="tab-minions" class="tab-button">Minions</button>
      </div>
      <div id="board" class="tab-panel">
        <div id="task-list">
          <h3>Story Tasks</h3>
        </div>
        <div id="repeatable-task-list">
          <h3>Resource Tasks</h3>
        </div>
        <div id="upgrade-panel">
          <h3>Upgrades</h3>
        </div>
      </div>
      <div id="path-panel" class="tab-panel">
        <h3>Path History</h3>
        <div id="path-history"></div>
      </div>
      <div id="combat-panel" class="tab-panel">
        <h3>Combat</h3>
        <div id="combat-content"></div>
      </div>
      <div id="minions-panel" class="tab-panel">
        <h3>Minions</h3>
        <div id="minions-content"></div>
      </div>
      <div id="log"></div>
    </div>
  </div>
  <div id="options-modal">
    <div id="options-content">
      <h3>Options</h3>
      <div class="options-section">
        <div class="options-section-title">Display Settings</div>
        <div class="option-item">
          <label>
            <input type="checkbox" id="show-proficiency">
            Show Proficiency on Resource Tasks
          </label>
        </div>
        <div class="option-item">
          <label>
            <input type="checkbox" id="show-estimated-time">
            Show Estimated Time on Resource Tasks
          </label>
        </div>
      </div>
      <div class="options-section">
        <div class="options-section-title">Gameplay Settings</div>
        <div class="option-item">
          <label>
            <input type="checkbox" id="notoriety-task-mode">
            Notoriety: 1/sec during Tasks Only
          </label>
        </div>
        <div class="option-item">
          <label>
            <input type="checkbox" id="developer-mode">
            Developer Mode (Instant Actions)
          </label>
        </div>
      </div>
      <div class="options-section">
        <div class="options-section-title">Save Management</div>
        <button id="export-save">Export Save</button>
        <input type="file" id="import-save" accept=".json">
        <button id="wipe-save">Wipe Save</button>
      </div>
      <button id="close-modal">Close</button>
    </div>
  </div>
  <script src="data.js"></script>
  <script src="scholar.js"></script>
  <script src="blade.js"></script>
  <script src="mask.js"></script>
  <script src="seal.js"></script>
  <script>
    // Merge route tasks into main tasks array
    if (typeof scholarTasks !== 'undefined') {
      tasks = tasks.concat(scholarTasks);
    }
    if (typeof bladeTasks !== 'undefined') {
      tasks = tasks.concat(bladeTasks);
    }
    if (typeof maskTasks !== 'undefined') {
      tasks = tasks.concat(maskTasks);
    }
    if (typeof sealTasks !== 'undefined') {
      tasks = tasks.concat(sealTasks);
    }
  </script>
  <script>
    let loopCount = 1;
    let currentTask = null;
    let taskProgress = 0;
    let statusMessage = "Begin your path to eternal dominion!";
    let buttons = [];
    let taskStartTime = 0;
    let logMessages = [];
    let lastSaveTime = 0;
    let settings = {
      showProficiency: true,
      showEstimatedTime: true,
      notorietyTaskMode: false,
      developerMode: false
    };
    let pathLog = {
      completions: {},
      choiceSelections: {},
      automation: {}
    };
    let combatState = {
      currentEnemy: null,
      enemyHealth: 0,
      enemyMaxHealth: 0,
      playerHealth: 100,
      playerMaxHealth: 100,
      combatActive: false,
      infamyThreshold: 80,
      infamy: 0
    };
    let minions = [];
    let minimizedNodes = {};
    const baseResources = JSON.parse(JSON.stringify(resources));

    // Debug logging helper with line numbers
    function debugLog(message, line) {
      if (settings.developerMode) {
        console.log(`[L${line}] ${message}`);
      }
    }

    function setup() {
      noCanvas();
      debugLog("Setup started", 64);
      loadGame();
      loadSettings();
      renderTaskList();
      renderUpgradeList();
      renderPathLog();
      renderCombatPanel();
      renderMinionsPanel();
      updateResourcesDisplay();
      setupOptionsModal();
      setupTabs();
      debugLog("Setup completed", 72);
    }

    function draw() {
      if (currentTask !== null) {
        taskProgress += 1 / 60;
        let task = tasks[currentTask];
        let progressPercent = (taskProgress / getTaskTime(task)) * 100;
        let progressBar = document.getElementById(`progress-${currentTask}`);
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
        
        // Evil progression mode: 1 per second during tasks
        if (settings.notorietyTaskMode && resources.evil) {
          resources.evil.value = Math.min(100, resources.evil.value + (1 / 60));
          updateEvilDisplay();
        }
        
        if (taskProgress >= getTaskTime(task)) {
          debugLog(`Task ${task.name} completed`, 92);
          completeTask();
        }
      }
      
      // Infamy generation from Evil
      if (resources.evil && resources.evil.value > 0) {
        combatState.infamy = Math.min(200, combatState.infamy + (resources.evil.value * 0.1 / 60));
        updateInfamyDisplay();
        checkCombatThresholds();
      }
      
      if (resources.evil && resources.evil.value >= 100) {
        debugLog("Evil reached 100, ending loop", 97);
        endLoop();
      }
      
      // Process resource interactions
      processResourceInteractions();
      
      // Process minion automation
      processMinionAutomation();
      if (frameCount % 600 === 0) { // Every 10 seconds
        debugLog("Auto-saving game", 101);
        saveGame();
      }
      updateResourcesDisplay();
      updateButtons();
      updateLog();
      updateStatus();
      checkStoryAutomation();
    }

    function saveGame() {
      debugLog("Saving game state", 111);
      const gameState = {
        resources,
        upgrades,
        tasks,
        loopCount,
        currentTask,
        taskProgress,
        logMessages,
        statusMessage,
        taskStartTime,
        settings,
        pathLog,
        combatState,
        minions
      };
      localStorage.setItem('necromancerGame', JSON.stringify(gameState));
      lastSaveTime = frameCount / 60;
      debugLog("Game saved successfully", 127);
    }

    function loadGame() {
      debugLog("Loading game", 131);
      const savedGame = localStorage.getItem('necromancerGame');
      if (savedGame) {
        try {
          const gameState = JSON.parse(savedGame);
          debugLog("Save file parsed successfully", 137);
          
          // Merge saved resources with default to ensure all exist
          resources = JSON.parse(JSON.stringify(baseResources));
          if (gameState.resources) {
            for (let key in gameState.resources) {
              if (resources[key]) {
                resources[key] = { ...resources[key], ...gameState.resources[key] };
              } else {
                resources[key] = gameState.resources[key];
              }
            }
          }
          
          upgrades = gameState.upgrades || upgrades;
          tasks = gameState.tasks || tasks;
          pathLog = gameState.pathLog || pathLog;
          combatState = gameState.combatState || combatState;
          minions = gameState.minions || [];
          
          // ensure pathLog sub-objects exist
          pathLog.completions = pathLog.completions || {};
          pathLog.choiceSelections = pathLog.choiceSelections || {};
          pathLog.automation = pathLog.automation || {};
          
          // Ensure all repeatable tasks have autoRepeat and minimized properties
          tasks.forEach((task, index) => {
            if (task.repeatable) {
              if (task.autoRepeat === undefined) {
                task.autoRepeat = false;
              }
              if (task.minimized === undefined) {
                task.minimized = false;
              }
            }
            if (task.completionsThisLoop === undefined) task.completionsThisLoop = 0;
            if (task.completionsTotal === undefined) task.completionsTotal = pathLog.completions[task.name] || 0;
          });
          
          loopCount = gameState.loopCount || 1;
          currentTask = gameState.currentTask || null;
          taskProgress = gameState.taskProgress || 0;
          logMessages = gameState.logMessages || [];
          statusMessage = gameState.statusMessage || "Begin your path to eternal dominion!";
          taskStartTime = gameState.taskStartTime || 0;
          settings = gameState.settings || settings;
          
          updateLoopDisplay();
          updateEvilDisplay();
          updateInfamyDisplay();
          updateLog();
          loadSettings();
          debugLog("Game loaded successfully", 189);
          
        } catch (error) {
          debugLog(`Error loading game: ${error.message}`, 192);
          alert("Error loading save file. Starting fresh game.");
          initializeDefaultGame();
        }
      } else {
        debugLog("No save file found, initializing default game", 197);
        initializeDefaultGame();
      }
    }

    function initializeDefaultGame() {
      debugLog("Initializing default game state", 202);
      tasks.forEach((task, index) => {
        if (task.repeatable) {
          if (task.autoRepeat === undefined) task.autoRepeat = false;
          if (task.minimized === undefined) task.minimized = false;
        }
        task.completionsThisLoop = task.completionsThisLoop || 0;
        task.completionsTotal = task.completionsTotal || 0;
      });
    }

    function loadSettings() {
      debugLog("Loading settings", 216);
      document.getElementById('show-proficiency').checked = settings.showProficiency;
      document.getElementById('show-estimated-time').checked = settings.showEstimatedTime;
      document.getElementById('notoriety-task-mode').checked = settings.notorietyTaskMode;
      document.getElementById('developer-mode').checked = settings.developerMode;
      
      // Apply developer mode if enabled
      if (settings.developerMode) {
        tasks.forEach((task, index) => {
          if (task.baseTime > 0) {
            task.originalBaseTime = task.baseTime;
            task.baseTime = 0.1;
          }
        });
      }
    }

    function setupOptionsModal() {
      debugLog("Setting up options modal", 235);
      const modal = document.getElementById('options-modal');
      const cogButton = document.getElementById('cog-button');
      const closeButton = document.getElementById('close-modal');
      const exportButton = document.getElementById('export-save');
      const importInput = document.getElementById('import-save');
      const wipeButton = document.getElementById('wipe-save');
      const showProficiencyCheck = document.getElementById('show-proficiency');
      const showEstimatedTimeCheck = document.getElementById('show-estimated-time');
      const notorietyTaskModeCheck = document.getElementById('notoriety-task-mode');
      const developerModeCheck = document.getElementById('developer-mode');

      loadSettings();

      showProficiencyCheck.addEventListener('change', (e) => {
        settings.showProficiency = e.target.checked;
        renderTaskList();
        saveGame();
        debugLog(`Show proficiency: ${settings.showProficiency}`, 254);
      });

      showEstimatedTimeCheck.addEventListener('change', (e) => {
        settings.showEstimatedTime = e.target.checked;
        renderTaskList();
        saveGame();
        debugLog(`Show estimated time: ${settings.showEstimatedTime}`, 260);
      });

      notorietyTaskModeCheck.addEventListener('change', (e) => {
        settings.notorietyTaskMode = e.target.checked;
        saveGame();
        debugLog(`Notoriety task mode: ${settings.notorietyTaskMode}`, 265);
      });

      developerModeCheck.addEventListener('change', (e) => {
        settings.developerMode = e.target.checked;
        if (settings.developerMode) {
          debugLog("Developer mode enabled", 270);
          // Store original times and set to near-instant
          tasks.forEach((task, index) => {
            if (task.baseTime > 0 && !task.originalBaseTime) {
              task.originalBaseTime = task.baseTime;
            }
            if (settings.developerMode) {
              task.baseTime = 0.1;
            }
          });
        } else {
          debugLog("Developer mode disabled", 281);
          // Restore original times
          tasks.forEach((task, index) => {
            if (task.originalBaseTime !== undefined) {
              task.baseTime = task.originalBaseTime;
              delete task.originalBaseTime;
            }
          });
        }
        renderTaskList();
        saveGame();
      });

      const focusableElements = modal.querySelectorAll('button, input');
      const firstFocusable = focusableElements[0];
      const lastFocusable = focusableElements[focusableElements.length - 1];

      cogButton.addEventListener('click', () => {
        modal.style.display = 'flex';
        firstFocusable.focus();
        debugLog("Options modal opened", 302);
      });

      closeButton.addEventListener('click', () => {
        modal.style.display = 'none';
        debugLog("Options modal closed", 306);
      });

      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.style.display = 'none';
          debugLog("Options modal closed via backdrop", 311);
        }
      });

      modal.addEventListener('keydown', (e) => {
        if (e.key === 'Tab') {
          if (e.shiftKey) {
            if (document.activeElement === firstFocusable) {
              e.preventDefault();
              lastFocusable.focus();
            }
          } else {
            if (document.activeElement === lastFocusable) {
              e.preventDefault();
              firstFocusable.focus();
            }
          }
        }
        if (e.key === 'Escape') {
          modal.style.display = 'none';
          debugLog("Options modal closed via Escape", 329);
        }
      });

      exportButton.addEventListener('click', () => {
        debugLog("Exporting save file", 333);
        const gameState = {
          resources,
          upgrades,
          tasks,
          loopCount,
          currentTask,
          taskProgress,
          logMessages,
          statusMessage,
          taskStartTime,
          settings,
          pathLog
        };
        const blob = new Blob([JSON.stringify(gameState, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'savegame.json';
        a.click();
        URL.revokeObjectURL(url);
        debugLog("Save file exported", 352);
      });

      importInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          debugLog("Importing save file", 358);
          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const gameState = JSON.parse(event.target.result);
              if (!gameState.resources || !gameState.upgrades || !gameState.tasks ||
                  !gameState.loopCount || !gameState.logMessages ||
                  !gameState.statusMessage || !gameState.taskStartTime) {
                throw new Error('Invalid save file structure');
              }
              
              // Merge saved resources with default
              resources = JSON.parse(JSON.stringify(baseResources));
              for (let key in gameState.resources) {
                if (resources[key]) {
                  resources[key] = { ...resources[key], ...gameState.resources[key] };
                } else {
                  resources[key] = gameState.resources[key];
                }
              }
              
              upgrades = gameState.upgrades;
              tasks = gameState.tasks;
              loopCount = gameState.loopCount;
              currentTask = gameState.currentTask;
              taskProgress = gameState.taskProgress;
              logMessages = gameState.logMessages;
              statusMessage = gameState.statusMessage;
              taskStartTime = gameState.taskStartTime;
              settings = gameState.settings || settings;
              pathLog = gameState.pathLog || pathLog;
              pathLog.completions = pathLog.completions || {};
              pathLog.choiceSelections = pathLog.choiceSelections || {};
              pathLog.automation = pathLog.automation || {};
              combatState = gameState.combatState || combatState;
              minions = gameState.minions || [];
              
              tasks.forEach((task, index) => {
                if (task.repeatable) {
                  if (task.autoRepeat === undefined) task.autoRepeat = false;
                  if (task.minimized === undefined) task.minimized = false;
                }
                if (task.completionsThisLoop === undefined) task.completionsThisLoop = 0;
                if (task.completionsTotal === undefined) task.completionsTotal = pathLog.completions[task.name] || 0;
              });
              
              saveGame();
              loadSettings();
              renderTaskList();
              renderUpgradeList();
              renderPathLog();
              updateResourcesDisplay();
              updateLoopDisplay();
              updateEvilDisplay();
              updateInfamyDisplay();
              updateLog();
              modal.style.display = 'none';
              debugLog("Save file imported successfully", 416);
              
            } catch (error) {
              debugLog(`Error importing save: ${error.message}`, 419);
              alert('Invalid save file: ' + error.message);
            }
          };
          reader.readAsText(file);
        }
      });

      wipeButton.addEventListener('click', () => {
        if (confirm('Are you sure you want to wipe your save?')) {
          debugLog("Wiping save file", 429);
          localStorage.removeItem('necromancerGame');
          location.reload();
        }
      });
    }

    function setupTabs() {
      debugLog("Setting up tabs", 437);
      const tabTasks = document.getElementById("tab-tasks");
      const tabPaths = document.getElementById("tab-paths");
      const tabCombat = document.getElementById("tab-combat");
      const tabMinions = document.getElementById("tab-minions");
      const board = document.getElementById("board");
      const pathPanel = document.getElementById("path-panel");
      const combatPanel = document.getElementById("combat-panel");
      const minionsPanel = document.getElementById("minions-panel");
      
      const activateTab = (tabName) => {
        // Remove active from all tabs and panels
        [tabTasks, tabPaths, tabCombat, tabMinions].forEach(tab => tab.classList.remove("active"));
        [board, pathPanel, combatPanel, minionsPanel].forEach(panel => panel.classList.remove("active"));
        
        if (tabName === "tasks") {
          tabTasks.classList.add("active");
          board.classList.add("active");
          debugLog("Switched to Tasks tab", 449);
        } else if (tabName === "paths") {
          tabPaths.classList.add("active");
          pathPanel.classList.add("active");
          renderPathLog();
          debugLog("Switched to Paths tab", 455);
        } else if (tabName === "combat") {
          tabCombat.classList.add("active");
          combatPanel.classList.add("active");
          renderCombatPanel();
          debugLog("Switched to Combat tab", 456);
        } else if (tabName === "minions") {
          tabMinions.classList.add("active");
          minionsPanel.classList.add("active");
          renderMinionsPanel();
          debugLog("Switched to Minions tab", 457);
        }
      };
      
      tabTasks.addEventListener('click', () => activateTab("tasks"));
      tabPaths.addEventListener('click', () => activateTab("paths"));
      tabCombat.addEventListener('click', () => activateTab("combat"));
      tabMinions.addEventListener('click', () => activateTab("minions"));
      
      // Initialize with Tasks tab active
      activateTab("tasks");
    }

    function renderTaskList() {
      debugLog("Rendering task list", 463);
      let taskList = document.getElementById("task-list");
      let repeatableTaskList = document.getElementById("repeatable-task-list");
      taskList.innerHTML = "<h3>Story Tasks</h3>";
      repeatableTaskList.innerHTML = "<h3>Resource Tasks</h3>";
      buttons = [];
      
      // Check if a SeedChoice has been made
      const seedChoiceMade = tasks.some(task => 
        task.choiceGroup === "SeedChoice" && task.completed
      );
      
      debugLog(`Seed choice made: ${seedChoiceMade}`, 476);
      
      tasks.forEach((task, index) => {
        if (!task.unlocked && task.unlockTask) {
          task.unlocked = tasks.some(t => t.name === task.unlockTask && t.completed);
        }
        
        // Check if this is a SeedChoice task that should be hidden due to exclusivity
        let isHiddenByExclusivity = false;
        if (task.choiceGroup === "SeedChoice" && seedChoiceMade) {
          // Hide all SeedChoice tasks if one has been completed, unless this one is completed
          if (!task.completed) {
            debugLog(`Hiding ${task.name} due to exclusive SeedChoice`, 488);
            isHiddenByExclusivity = true;
          }
        }
        
        // CHANGE: For repeatable/resource tasks, only show if uses remain (hasCompletions)
        let hasCompletions = !task.maxCompletions || task.completionsThisLoop < task.maxCompletions;
        let isVisible = !isHiddenByExclusivity && (task.repeatable ? 
          ((task.unlocked || !task.unlockTask) && hasCompletions) : 
          (!task.completed && (!task.requires || task.requires.every(req => 
            tasks.find(t => t.name === req).completed
          ))));
        
        if (isVisible) {
          let isLocked = task.requires && !task.requires.every(req => 
            tasks.find(t => t.name === req).completed
          );
          let hasResources = checkResources(task);
          let hasCompletions = !task.maxCompletions || task.completionsThisLoop < task.maxCompletions;
          
          let card = document.createElement("div");
          let cardClasses = `task-card ${isLocked ? "locked" : ""} ${task.repeatable ? "repeatable" : ""} ${task.safe ? "safe" : ""}`;
          
          // Only apply minimized class to repeatable tasks
          if (task.repeatable && task.minimized) {
            cardClasses += " minimized";
          }
          
          card.className = cardClasses;
          
          let adjustedCost = task.cost ? Object.entries(task.cost).reduce((acc, [k, v]) => {
            let cost = v;
            if (k === "mana" && upgrades.manaEfficiency.level > 0) {
              cost *= (1 - 0.1 * upgrades.manaEfficiency.level);
            }
            if (upgrades.nihilisticResolve.level > 0) {
              cost *= (1 - 0.05 * upgrades.nihilisticResolve.level);
            }
            acc[k] = Math.ceil(cost);
            return acc;
          }, {}) : {};
          
          let costText = task.cost ? `Cost: ${Object.entries(adjustedCost).map(([k, v]) => `${k}: ${v}`).join(", ")}` : "";
          let yieldsText = task.yields ? `Yields: ${Object.entries(task.yields).map(([k, v]) => `${k}: ${v}`).join(", ")}` : "";
          let notorietyText = task.notorietyCost ? `Notoriety: ${task.notorietyCost > 0 ? "+" : ""}${task.notorietyCost}` : "";
          let proficiencyText = "";
          
          if (task.repeatable) {
            if (settings.showProficiency) {
              proficiencyText = `<div>Proficiency: ${task.proficiency}</div>`;
            }
          } else {
            proficiencyText = `<div>Proficiency: ${task.proficiency}</div>`;
          }
          
          let estimatedTimeText = "";
          if (task.repeatable && settings.showEstimatedTime) {
            let estimatedTime = getTaskTime(task);
            estimatedTimeText = `<div>Time: ~${estimatedTime.toFixed(1)}s</div>`;
          }
          
          let autoRepeatToggle = "";
          let minimizeButton = "";
          if (task.repeatable) {
            autoRepeatToggle = `
              <div class="auto-repeat-toggle">
                <label>
                  <input type="checkbox" class="auto-repeat-checkbox" data-task-index="${index}" ${task.autoRepeat ? 'checked' : ''}>
                  Auto Repeat
                </label>
              </div>
            `;
            let minimizeSymbol = task.minimized ? "+" : "−";
            minimizeButton = `<button class="minimize-button" data-task-index="${index}">${minimizeSymbol}</button>`;
          }
          
          let taskContent = `
            <div class="task-content">
              <div>${task.description}</div>
              ${proficiencyText}
              ${estimatedTimeText}
              ${costText ? `<div>${costText}</div>` : ""}
              ${yieldsText ? `<div>${yieldsText}</div>` : ""}
              ${notorietyText ? `<div>${notorietyText}</div>` : ""}
              ${task.maxCompletions ? `<div>Uses left: ${task.maxCompletions - task.completionsThisLoop}/${task.maxCompletions}</div>` : ""}
              ${autoRepeatToggle}
              <div class="progress-bar"><div class="progress" id="progress-${index}"></div></div>
            </div>
          `;
          
          // For story tasks (non-repeatable), always show content. For resource tasks, check minimized state
          let shouldShowContent = !task.repeatable || !task.minimized;
          
          card.innerHTML = `
            <div class="task-header">
              <div class="task-name">${task.name}</div>
              ${minimizeButton}
            </div>
            ${shouldShowContent ? taskContent : ""}
          `;
          
          if (!isLocked && (task.unlocked || !task.unlockTask) && hasCompletions) {
            // Only show start button if task is not minimized (only applies to repeatable tasks)
            let shouldShowButton = !task.repeatable || !task.minimized;
            
            if (shouldShowButton) {
              let btn = createButton(`${task.name}`);
              btn.elt.style.marginTop = "8px";
              btn.elt.id = `button-${index}`;
              
              // Disable button if another SeedChoice has been made
              let isDisabledByExclusivity = false;
              if (task.choiceGroup === "SeedChoice" && seedChoiceMade && !task.completed) {
                isDisabledByExclusivity = true;
                debugLog(`Disabling ${task.name} due to exclusive SeedChoice already made`, 603);
              }
              
              btn.elt.disabled = isDisabledByExclusivity || !hasResources || currentTask !== null || !hasCompletions;
              btn.mousePressed(() => startTask(index));
              btn.parent(card);
            }
            
            // Add event listener for auto-repeat toggle (only for repeatable tasks)
            if (task.repeatable) {
              let checkbox = card.querySelector('.auto-repeat-checkbox');
              if (checkbox) {
                checkbox.addEventListener('change', (e) => {
                  tasks[index].autoRepeat = e.target.checked;
                  saveGame();
                  debugLog(`Auto-repeat for ${task.name}: ${e.target.checked}`, 617);
                });
              }
              
              // Add event listener for minimize button (only for repeatable tasks)
              let minimizeBtn = card.querySelector('.minimize-button');
              if (minimizeBtn) {
                minimizeBtn.addEventListener('click', (e) => {
                  e.stopPropagation();
                  // Only toggle minimized state for repeatable tasks
                  if (tasks[index].repeatable) {
                    tasks[index].minimized = !tasks[index].minimized;
                    renderTaskList();
                    saveGame();
                    debugLog(`Minimized ${task.name}: ${tasks[index].minimized}`, 630);
                  }
                });
              }
            }
            
            // Add resource/completion warnings only if content is visible
            if (shouldShowContent) {
              if (!hasResources) {
                let contentDiv = card.querySelector('.task-content');
                if (contentDiv) {
                  contentDiv.innerHTML += `<div>Insufficient resources: ${costText}</div>`;
                }
              }
              if (!hasCompletions) {
                let contentDiv = card.querySelector('.task-content');
                if (contentDiv) {
                  contentDiv.innerHTML += `<div>No uses left this cycle</div>`;
                }
              }
            }
            
            // Update progress bar if task is active
            if (currentTask === index) {
              let progressBar = document.getElementById(`progress-${index}`);
              if (progressBar) {
                let progressPercent = (taskProgress / getTaskTime(task)) * 100;
                progressBar.style.width = `${progressPercent}%`;
              }
            }
          } else {
            let lockReason = isLocked ? `Requires: ${task.requires.join(", ")}` : 
                           !task.unlocked ? `Locked: Complete ${task.unlockTask}` : 
                           !hasCompletions ? "No uses left this cycle" : 
                           `Insufficient resources: ${costText}`;
            card.innerHTML += `<div>${lockReason}</div>`;
          }
          
          if (task.repeatable) {
            repeatableTaskList.appendChild(card);
          } else {
            taskList.appendChild(card);
          }
        }
      });
      debugLog("Task list rendering complete", 676);
    }

    function renderPathLog() {
      debugLog("Rendering path log", 680);
      const panel = document.getElementById("path-history");
      if (!panel) return;
      panel.innerHTML = "";
      
      // Build tree structure
      const taskTree = {};
      const taskByName = {};
      
      // First pass: create nodes
      tasks.forEach(task => {
        taskByName[task.name] = {
          ...task,
          children: [],
          parent: null
        };
      });
      
      // Second pass: build tree structure
      tasks.forEach(task => {
        const node = taskByName[task.name];
        
        // Connect via requires
        if (task.requires && task.requires.length > 0) {
          task.requires.forEach(parentName => {
            const parent = taskByName[parentName];
            if (parent) {
              node.parent = parent;
              if (!parent.children.some(child => child.name === task.name)) {
                parent.children.push(node);
              }
            }
          });
        }
        
        // Connect via unlocks
        if (task.unlocks && Array.isArray(task.unlocks)) {
          task.unlocks.forEach(childName => {
            const child = taskByName[childName];
            if (child && !node.children.some(c => c.name === child.name)) {
              node.children.push(child);
              child.parent = node;
            }
          });
        }
      });
      
      // Find root nodes (tasks with no requires)
      const roots = Object.values(taskByName).filter(task => 
        (!task.requires || task.requires.length === 0) && !task.repeatable
      );
      
      // Recursive function to render tree
      function renderTreeNode(node, depth = 0, parentSelected = true) {
        const container = document.createElement("div");
        container.className = "tree-node";
        container.style.marginLeft = `${depth * 20}px`;
        
        // Check if this node should be visible
        const completions = pathLog.completions[node.name] || 0;
        const isCompleted = completions > 0 || node.completed;
        const isChoiceNode = node.choiceGroup && node.choiceParentGroup;
        
        // Hide unseen story beats
        let shouldShow = false;
        
        if (isChoiceNode) {
          // For choice nodes, check parent selection
          const parentGroup = node.choiceParentGroup;
          const parentKey = node.choiceParentKey;
          if (parentGroup && pathLog.choiceSelections[parentGroup] !== parentKey) {
            return container; // Don't show unselected branches
          }
          shouldShow = true;
        } else if (!node.repeatable) {
          // For story tasks, show if:
          // 1. It's completed
          // 2. Or a parent is completed (showing available but unpicked)
          // 3. Or it's a root node
          const parentCompleted = node.parent ? 
            (pathLog.completions[node.parent.name] > 0 || node.parent.completed) : 
            true;
          shouldShow = isCompleted || parentCompleted || depth === 0;
        } else {
          // For repeatable tasks, show if unlocked
          shouldShow = node.unlocked || !node.unlockTask;
        }
        
        if (!shouldShow && depth > 0) {
          return container;
        }
        
        const card = document.createElement("div");
        const pickedClass = isCompleted ? "picked" : "unpicked";
        card.className = `path-card ${pickedClass} ${node.repeatable ? "repeatable" : ""}`;
        
        // Build connections visualization
        let connectionHTML = "";
        if (depth > 0) {
          connectionHTML = `<div class="tree-connector" style="height: 2px; background: #4a1a4a; margin-bottom: 5px;"></div>`;
        }
        
        card.innerHTML = `
          ${connectionHTML}
          <div class="path-card-title">${node.name} ${node.repeatable ? "⟳" : ""}</div>
          <div class="path-card-desc">${node.description}</div>
          ${!node.repeatable ? `<div class="path-card-count">Completions: ${completions}</div>` : ""}
          ${node.choiceGroup ? `<div class="path-card-choice">Choice: ${node.choiceKey}</div>` : ""}
        `;
        
        // Add automation toggle for story tasks
        const automationAvailable = completions >= 5 && !node.repeatable;
        if (automationAvailable) {
          const toggle = document.createElement("label");
          toggle.className = "auto-story-toggle";
          const checked = pathLog.automation[node.name] ? "checked" : "";
          toggle.innerHTML = `
            <input type="checkbox" data-task-name="${node.name}" ${checked}>
            Automate after unlock
          `;
          toggle.addEventListener("change", (e) => {
            pathLog.automation[node.name] = e.target.checked;
            saveGame();
            debugLog(`Automation for ${node.name}: ${e.target.checked}`, 777);
          });
          card.appendChild(toggle);
        }
        
        // Add minimize button to each node
        const minimizeBtn = document.createElement('button');
        minimizeBtn.className = 'minimize-tree-btn';
        minimizeBtn.innerText = minimizedNodes[node.name] ? "+" : "−";
        minimizeBtn.addEventListener('click', e => {
          e.stopPropagation();
          minimizedNodes[node.name] = !minimizedNodes[node.name];
          renderPathLog();
        });
        card.prepend(minimizeBtn);

        container.appendChild(card);
        
        // Sort children: completed first, then by name
        const sortedChildren = [...node.children].sort((a, b) => {
          const aCompleted = pathLog.completions[a.name] > 0 || a.completed;
          const bCompleted = pathLog.completions[b.name] > 0 || b.completed;
          if (aCompleted && !bCompleted) return -1;
          if (!aCompleted && bCompleted) return 1;
          return a.name.localeCompare(b.name);
        });
        
        // Render children
        sortedChildren.forEach(child => {
          const childContainer = renderTreeNode(child, depth + 1, isCompleted || parentSelected);
          container.appendChild(childContainer);
        });
        
        return container;
      }
      
      // Render all roots
      roots.sort((a, b) => {
        const aCompleted = pathLog.completions[a.name] > 0 || a.completed;
        const bCompleted = pathLog.completions[b.name] > 0 || b.completed;
        if (aCompleted && !bCompleted) return -1;
        if (!aCompleted && bCompleted) return 1;
        return a.name.localeCompare(b.name);
      });
      
      roots.forEach(root => {
        const rootContainer = renderTreeNode(root, 0);
        if (rootContainer.children.length > 0) {
          panel.appendChild(rootContainer);
        }
      });
      
      // Add CSS for tree
      const style = document.createElement('style');
      style.textContent = `
        .tree-node {
          margin: 5px 0;
        }
        .tree-connector {
          width: 100%;
          opacity: 0.3;
        }
        .path-card.repeatable {
          background: rgba(40, 20, 40, 0.7);
        }
        .path-card.picked {
          border-left: 3px solid #6a2a6a;
        }
        .path-card.unpicked {
          border-left: 3px solid #3a1a3a;
          opacity: 0.7;
        }
        .path-card-choice {
          font-size: 11px;
          color: #8a6a8a;
          font-style: italic;
          margin-top: 2px;
        }
      `;
      panel.appendChild(style);
      debugLog("Path log rendering complete", 834);
    }

    function renderUpgradeList() {
      debugLog("Rendering upgrade list", 838);
      let upgradePanel = document.getElementById("upgrade-panel");
      upgradePanel.innerHTML = "<h3>Upgrades</h3>";
      Object.entries(upgrades).forEach(([key, upgrade]) => {
        if (!upgrade.unlocked) {
          upgrade.unlocked = tasks.some(t => t.name === upgrade.unlockTask && t.completed);
        }
        if (upgrade.unlocked) {
          let canAfford = checkResources({ cost: upgrade.cost });
          let isMaxed = upgrade.level >= upgrade.maxLevel;
          let adjustedCost = {};
          for (let [resource, amount] of Object.entries(upgrade.cost)) {
            let cost = amount;
            if (resource === "mana" && upgrades.manaEfficiency.level > 0) {
              cost *= (1 - 0.1 * upgrades.manaEfficiency.level);
            }
            if (upgrades.nihilisticResolve.level > 0) {
              cost *= (1 - 0.05 * upgrades.nihilisticResolve.level);
            }
            adjustedCost[resource] = Math.ceil(cost);
          }
          let costText = `Cost: ${Object.entries(adjustedCost).map(([k, v]) => `${k}: ${v}`).join(", ")}`;
          let card = document.createElement("div");
          card.className = `upgrade-card ${!canAfford || isMaxed ? "locked" : ""}`;
          card.innerHTML = `
            <div class="upgrade-name">${key.replace(/([A-Z])/g, ' $1').trim()}</div>
            <div>${upgrade.description}</div>
            <div>Level: ${upgrade.level}/${upgrade.maxLevel}</div>
            <div>${costText}</div>
          `;
          if (!isMaxed && canAfford) {
            let btn = createButton("Buy");
            btn.elt.style.marginTop = "5px";
            btn.mousePressed(() => purchaseUpgrade(key));
            btn.parent(card);
          } else {
            card.innerHTML += `<div>${isMaxed ? "Max level reached" : "Insufficient resources"}</div>`;
          }
          upgradePanel.appendChild(card);
        }
      });
      debugLog("Upgrade list rendering complete", 877);
    }

    function startTask(index) {
      debugLog(`Starting task ${tasks[index].name}`, 880);
      if (currentTask === null && (!tasks[index].completed || tasks[index].repeatable)) {
        let task = tasks[index];
        let isLocked = task.requires && !task.requires.every(req => 
          tasks.find(t => t.name === req).completed
        );
        let hasResources = checkResources(task);
        let hasCompletions = !task.maxCompletions || task.completionsThisLoop < task.maxCompletions;
        
        // Check if this is a SeedChoice task and if another has been completed
        let isBlockedByExclusiveChoice = false;
        if (task.choiceGroup === "SeedChoice") {
          const otherSeedChoiceCompleted = tasks.some(t => 
            t.choiceGroup === "SeedChoice" && 
            t.name !== task.name && 
            t.completed
          );
          if (otherSeedChoiceCompleted) {
            isBlockedByExclusiveChoice = true;
            debugLog(`Cannot start ${task.name}: another SeedChoice already made`, 897);
          }
        }
        
        if (!isLocked && !isBlockedByExclusiveChoice && hasResources && (task.unlocked || !task.unlockTask) && hasCompletions) {
          task.isActive = true;
          currentTask = index;
          taskProgress = 0;
          taskStartTime = frameCount / 60;
          statusMessage = `Performing ${task.name}...`;
          
          if (task.cost) {
            for (let [resource, amount] of Object.entries(task.cost)) {
              resources[resource].value -= amount;
              debugLog(`Deducted ${amount} ${resource}`, 910);
            }
          }
          
          // Immediately update all displays when task starts
          updateResourcesDisplay();
          renderTaskList();
          renderUpgradeList();
          updateButtons();
          saveGame();
          debugLog(`Task ${task.name} started successfully`, 919);
        }
      }
    }

    function completeTask() {
      debugLog("Completing task", 924);
      let task = tasks[currentTask];
      let completionTime = (frameCount / 60 - taskStartTime).toFixed(2);
      task.proficiency++;
      task.isActive = false;
      task.completionsTotal = (task.completionsTotal || 0) + 1;
      pathLog.completions[task.name] = (pathLog.completions[task.name] || 0) + 1;
      
      if (task.choiceGroup) {
        pathLog.choiceSelections[task.choiceGroup] = task.choiceKey;
        debugLog(`Choice made: ${task.choiceGroup} = ${task.choiceKey}`, 934);
        // Now generalize to all choiceGroups
        tasks.forEach(t => {
          if (t.choiceGroup === task.choiceGroup && t.name !== task.name) {
            t.completed = true;
            debugLog(`Locked ${t.name} due to exclusive choice group ${task.choiceGroup}`, 942);
          }
        });
      }
      
      if (!task.repeatable) {
        task.completed = true;
        if (task.resourceMaxIncrease) {
          for (let [resource, amount] of Object.entries(task.resourceMaxIncrease)) {
            resources[resource].max += amount;
            resources[resource].unlocked = true;
            debugLog(`Increased ${resource} max by ${amount}`, 952);
          }
        }
        if (task.name === "Survive Plague") {
          resources.knowledge.unlocked = true;
          resources.knowledge.value = Math.min(resources.knowledge.value + 3, resources.knowledge.max);
          debugLog("Knowledge unlocked and increased", 958);
        }
        if (task.name === "Unlock Control") {
          resources.control.unlocked = true;
          debugLog("Control unlocked", 959);
        }
      }
      
      if (task.maxCompletions) {
        task.completionsThisLoop++;
        debugLog(`Completions this loop: ${task.completionsThisLoop}/${task.maxCompletions}`, 963);
      }
      
      // Create minion if task specifies
      if (task.createsMinion) {
        const controlUsed = minions.reduce((sum, m) => sum + m.controlCost, 0);
        const controlMax = resources.control?.max || 0;
        if (controlUsed + task.createsMinion.controlCost <= controlMax) {
          // Scale minion power based on story progression
          const storyTasksCompleted = tasks.filter(t => !t.repeatable && t.completed).length;
          const scalingFactor = 1 + (storyTasksCompleted * 0.1); // 10% per story task
          const scaledPower = Math.floor(task.createsMinion.power * scalingFactor);
          
          const scaledMinion = {
            ...task.createsMinion,
            power: scaledPower
          };
          
          minions.push(scaledMinion);
          logMessages.unshift(`Created ${task.createsMinion.name} (Power: ${scaledPower})!`);
          if (logMessages.length > 10) logMessages.pop();
          renderMinionsPanel();
          debugLog(`Created minion: ${task.createsMinion.name} with power ${scaledPower}`, 964);
        } else {
          logMessages.unshift(`Not enough control to create ${task.createsMinion.name}.`);
          if (logMessages.length > 10) logMessages.pop();
        }
      }
      
      if (task.yields) {
        for (let [resource, amount] of Object.entries(task.yields)) {
          let adjustedAmount = amount;
          if (resource === "knowledge" && upgrades.knowledgeBoost.level > 0) {
            adjustedAmount += upgrades.knowledgeBoost.level;
            debugLog(`Knowledge boost applied: +${upgrades.knowledgeBoost.level}`, 971);
          }
          resources[resource].value = Math.min(
            resources[resource].value + adjustedAmount,
            resources[resource].max
          );
          resources[resource].unlocked = true;
          debugLog(`Gained ${adjustedAmount} ${resource}`, 978);
        }
        updateResourcesDisplay();
      }
      
      if (task.notorietyCost && !task.safe && !settings.notorietyTaskMode) {
        if (resources.evil) {
          resources.evil.value = Math.max(0, Math.min(100, resources.evil.value + task.notorietyCost));
          updateEvilDisplay();
          debugLog(`Evil changed by ${task.notorietyCost}`, 986);
        }
      }
      
      // Add flavor message after story task completion
      if (!task.repeatable && task.flavorMessage) {
        logMessages.unshift(task.flavorMessage);
        if (logMessages.length > 10) logMessages.pop();
      }
      
      tasks.forEach(t => {
        if (t.unlockTask === task.name) {
          t.unlocked = true;
          debugLog(`Unlocked ${t.name}`, 992);
        }
      });
      
      statusMessage = `${task.name} completed!`;
      logMessages.unshift(`${task.name} completed in ${completionTime}s`);
      if (logMessages.length > 10) logMessages.pop();
      updateLog();
      
      currentTask = null;
      taskProgress = 0;
      renderTaskList();
      renderUpgradeList();
      renderPathLog();
      saveGame();
      
      if (tasks.filter(t => !t.repeatable).every(t => t.completed)) {
        statusMessage = "Knowledge amassed! Choose your path to power.";
        debugLog("All story tasks completed!", 1009);
      }
      
      // Auto-repeat for repeatable tasks (per-task setting)
      if (task.repeatable && task.autoRepeat) {
        let taskIndex = tasks.findIndex(t => t.name === task.name);
        if (taskIndex !== -1) {
          let repeatTask = tasks[taskIndex];
          let hasResources = checkResources(repeatTask);
          let hasCompletions = !repeatTask.maxCompletions || repeatTask.completionsThisLoop < repeatTask.maxCompletions;
          if (hasResources && hasCompletions && (repeatTask.unlocked || !repeatTask.unlockTask)) {
            debugLog(`Auto-repeating ${repeatTask.name}`, 1021);
            // Small delay to allow UI to update
            setTimeout(() => {
              startTask(taskIndex);
            }, 100);
          }
        }
      }
      debugLog("Task completion process finished", 1028);
    }

    function purchaseUpgrade(key) {
      debugLog(`Purchasing upgrade: ${key}`, 1032);
      let upgrade = upgrades[key];
      if (upgrade.level < upgrade.maxLevel && checkResources({ cost: upgrade.cost })) {
        for (let [resource, amount] of Object.entries(upgrade.cost)) {
          resources[resource].value -= amount;
          debugLog(`Paid ${amount} ${resource} for upgrade`, 1037);
        }
        upgrade.level++;
        statusMessage = `${key.replace(/([A-Z])/g, ' $1').trim()} upgraded to level ${upgrade.level}!`;
        logMessages.unshift(statusMessage);
        if (logMessages.length > 10) logMessages.pop();
        updateLog();
        updateResourcesDisplay();
        renderUpgradeList();
        renderTaskList();
        saveGame();
        debugLog(`Upgrade ${key} purchased, now level ${upgrade.level}`, 1048);
      } else {
        debugLog(`Cannot purchase ${key}: insufficient resources or max level`, 1050);
      }
    }

    function checkResources(task) {
      debugLog(`Checking resources for task`, 1054);
      if (!task.cost) {
        debugLog("No cost, returning true", 1056);
        return true;
      }
      let adjustedCost = {};
      for (let [resource, amount] of Object.entries(task.cost)) {
        let cost = amount;
        if (resource === "mana" && upgrades.manaEfficiency.level > 0) {
          cost *= (1 - 0.1 * upgrades.manaEfficiency.level);
          debugLog(`Mana efficiency applied: ${cost}`, 1064);
        }
        if (upgrades.nihilisticResolve.level > 0) {
          cost *= (1 - 0.05 * upgrades.nihilisticResolve.level);
          debugLog(`Nihilistic resolve applied: ${cost}`, 1068);
        }
        adjustedCost[resource] = Math.ceil(cost);
      }
      
      const hasResources = Object.entries(adjustedCost).every(([resource, amount]) => {
        const has = resources[resource].value >= amount;
        if (!has) {
          debugLog(`Missing ${amount - resources[resource].value} ${resource}`, 1075);
        }
        return has;
      });
      
      debugLog(`Has resources: ${hasResources}`, 1079);
      return hasResources;
    }

    function getTaskTime(task) {
      let time = task.baseTime * (1 - task.proficiency * 0.1);
      if (upgrades.swiftRituals.level > 0) {
        time *= (1 - 0.1 * upgrades.swiftRituals.level);
        debugLog(`Swift rituals reduction: ${time}`, 1087);
      }
      if (upgrades.crowFamiliar.level > 0) {
        time *= (1 - 0.05 * upgrades.crowFamiliar.level);
        debugLog(`Crow familiar reduction: ${time}`, 1091);
      }
      const result = Math.max(0.1, time);
      debugLog(`Task time for ${task.name}: ${result}`, 1094);
      return result;
    }

    function endLoop() {
      debugLog("Ending loop", 1098);
      loopCount++;
      if (resources.evil) {
        resources.evil.value = 0;
      }
      currentTask = null;
      taskProgress = 0;
      for (let task of tasks) {
        task.isActive = false;
        if (!task.repeatable) {
          task.completed = false;
        }
        if (task.maxCompletions) {
          task.completionsThisLoop = 0;
        }
      }
      for (let key in upgrades) {
        upgrades[key].level = 0;
      }
      statusMessage = "Notoriety discovered! Time loop resets with greater mastery.";
      logMessages.unshift(`Cycle ${loopCount - 1} ended. Loop reset.`);
      if (logMessages.length > 10) logMessages.pop();
      updateLog();
      updateLoopDisplay();
      updateEvilDisplay();
      renderTaskList();
      renderUpgradeList();
      saveGame();
      debugLog(`Loop ended, now cycle ${loopCount}`, 1122);
    }

    function updateLoopDisplay() {
      document.getElementById("loop").innerText = `Cycle: ${loopCount}`;
      debugLog(`Updated loop display: ${loopCount}`, 1127);
    }

    function updateEvilDisplay() {
      if (resources.evil) {
        document.getElementById("evil").innerText = `Evil: ${Math.floor(resources.evil.value)}/100`;
        document.getElementById("evil-progress").style.width = `${Math.max(0, Math.min(100, (resources.evil.value / 100) * 100))}%`;
        debugLog(`Updated evil display: ${Math.floor(resources.evil.value)}/100`, 1135);
      }
    }
    
    function updateInfamyDisplay() {
      document.getElementById("infamy").innerText = `Infamy: ${Math.floor(combatState.infamy)}`;
    }
    
    function checkCombatThresholds() {
      if (!combatState.combatActive && combatState.infamy >= combatState.infamyThreshold) {
        startCombat();
      }
    }
    
    function startCombat() {
      combatState.combatActive = true;
      let enemyType = "";
      let health = 0;
      
      if (combatState.infamy >= 200) {
        enemyType = "All Gods";
        health = 5000;
      } else if (combatState.infamy >= 150) {
        enemyType = "A God";
        health = 2000;
      } else if (combatState.infamy >= 100) {
        enemyType = "Coalition of Countries";
        health = 1000;
      } else if (combatState.infamy >= 90) {
        enemyType = "King";
        health = 500;
      } else {
        enemyType = "Mob of Villagers";
        health = 200;
      }
      
      combatState.currentEnemy = enemyType;
      combatState.enemyHealth = health;
      combatState.enemyMaxHealth = health;
      renderCombatPanel();
      logMessages.unshift(`Combat started: ${enemyType} attacks!`);
      if (logMessages.length > 10) logMessages.pop();
      updateLog();
    }
    
    function renderCombatPanel() {
      const panel = document.getElementById("combat-content");
      if (!panel) return;
      
      if (!combatState.combatActive) {
        panel.innerHTML = `
          <div class="combat-info">
            <p>No active combat.</p>
            <p>Infamy: ${Math.floor(combatState.infamy)}/${combatState.infamyThreshold}</p>
            <p>Next threshold: ${getNextEnemyName()}</p>
          </div>
        `;
        return;
      }
      
      const healthPercent = (combatState.enemyHealth / combatState.enemyMaxHealth) * 100;
      const playerHealthPercent = (combatState.playerHealth / combatState.playerMaxHealth) * 100;
      
      panel.innerHTML = `
        <div class="combat-info">
          <h4>${combatState.currentEnemy}</h4>
          <div class="health-bar">
            <div class="health-bar-label">Enemy Health</div>
            <div class="health-bar-container">
              <div class="health-bar-fill enemy" style="width: ${healthPercent}%"></div>
            </div>
            <div class="health-bar-text">${Math.floor(combatState.enemyHealth)}/${combatState.enemyMaxHealth}</div>
          </div>
          <div class="health-bar">
            <div class="health-bar-label">Your Health</div>
            <div class="health-bar-container">
              <div class="health-bar-fill player" style="width: ${playerHealthPercent}%"></div>
            </div>
            <div class="health-bar-text">${Math.floor(combatState.playerHealth)}/${combatState.playerMaxHealth}</div>
          </div>
          <button id="attack-button">Attack</button>
        </div>
      `;
      
      const attackBtn = document.getElementById("attack-button");
      if (attackBtn) {
        attackBtn.addEventListener('click', performAttack);
      }
    }
    
    function getNextEnemyName() {
      if (combatState.infamyThreshold >= 200) return "All Gods";
      if (combatState.infamyThreshold >= 150) return "A God";
      if (combatState.infamyThreshold >= 100) return "Coalition of Countries";
      if (combatState.infamyThreshold >= 90) return "King";
      return "Mob of Villagers";
    }
    
    function performAttack() {
      if (!combatState.combatActive) return;
      
      // Calculate damage based on path and resources
      let damage = calculateCombatDamage();
      combatState.enemyHealth = Math.max(0, combatState.enemyHealth - damage);
      
      // Enemy counterattack
      let enemyDamage = calculateEnemyDamage();
      combatState.playerHealth = Math.max(0, combatState.playerHealth - enemyDamage);
      
      renderCombatPanel();
      
      if (combatState.enemyHealth <= 0) {
        winCombat();
      } else if (combatState.playerHealth <= 0) {
        loseCombat();
      }
    }
    
    function calculateCombatDamage() {
      let baseDamage = 10;
      
      // Path-specific damage calculations
      const seedChoice = pathLog.choiceSelections["SeedChoice"];
      
      if (seedChoice === "Blade") {
        baseDamage += (resources.fury?.value || 0) * 0.5;
        baseDamage += (resources.armaments?.value || 0) * 2;
        baseDamage += getMinionCombatPower();
      } else if (seedChoice === "Book") {
        baseDamage += (resources.knowledge?.value || 0) * 0.3;
        baseDamage += (resources.evidence?.value || 0) * 1.5;
      } else if (seedChoice === "Mask") {
        baseDamage += (resources.influence?.value || 0) * 0.4;
        baseDamage += (resources.secrets?.value || 0) * 1.2;
      } else if (seedChoice === "Seal") {
        baseDamage += (resources.voidFavor?.value || 0) * 0.6;
        baseDamage += (resources.entropy?.value || 0) * 2;
      }
      
      return Math.floor(baseDamage);
    }
    
    function calculateEnemyDamage() {
      let baseDamage = 5;
      if (combatState.infamy >= 200) baseDamage = 50;
      else if (combatState.infamy >= 150) baseDamage = 30;
      else if (combatState.infamy >= 100) baseDamage = 20;
      else if (combatState.infamy >= 90) baseDamage = 10;
      
      // Minions can absorb damage
      const minionAbsorption = getMinionAbsorption();
      return Math.max(1, Math.floor(baseDamage - minionAbsorption));
    }
    
    function winCombat() {
      combatState.combatActive = false;
      combatState.infamy = 0;
      
      // Increase threshold
      if (combatState.infamyThreshold === 80) combatState.infamyThreshold = 90;
      else if (combatState.infamyThreshold === 90) combatState.infamyThreshold = 100;
      else if (combatState.infamyThreshold === 100) combatState.infamyThreshold = 150;
      else if (combatState.infamyThreshold === 150) combatState.infamyThreshold = 200;
      else if (combatState.infamyThreshold === 200) combatState.infamyThreshold = 250;
      
      combatState.playerHealth = combatState.playerMaxHealth;
      logMessages.unshift(`Victory! ${combatState.currentEnemy} defeated!`);
      if (logMessages.length > 10) logMessages.pop();
      updateLog();
      renderCombatPanel();
    }
    
    function loseCombat() {
      combatState.combatActive = false;
      logMessages.unshift(`Defeat! ${combatState.currentEnemy} overwhelmed you.`);
      if (logMessages.length > 10) logMessages.pop();
      updateLog();
      renderCombatPanel();
    }
    
    function renderMinionsPanel() {
      const panel = document.getElementById("minions-content");
      if (!panel) return;
      
      const controlUsed = minions.reduce((sum, m) => sum + m.controlCost, 0);
      const controlMax = resources.control?.max || 0;
      
      panel.innerHTML = `
        <div class="minions-info">
          <h4>Control: ${controlUsed}/${controlMax}</h4>
          <div id="minions-list"></div>
        </div>
      `;
      
      const list = document.getElementById("minions-list");
      if (minions.length === 0) {
        list.innerHTML = "<p>No minions yet.</p>";
      } else {
        list.innerHTML = minions.map((minion, index) => `
          <div class="minion-card">
            <div class="minion-name">${minion.name}</div>
            <div class="minion-stats">Power: ${minion.power}, Control: ${minion.controlCost}</div>
            <button onclick="dismissMinion(${index})">Dismiss</button>
          </div>
        `).join("");
      }
    }
    
    window.dismissMinion = function(index) {
      minions.splice(index, 1);
      renderMinionsPanel();
      saveGame();
    };
    
    function getMinionCombatPower() {
      return minions.reduce((sum, m) => sum + m.power, 0);
    }
    
    function getMinionAbsorption() {
      return minions.reduce((sum, m) => sum + (m.power * 0.1), 0);
    }
    
    function processMinionAutomation() {
      if (currentTask !== null) return;
      
      minions.forEach(minion => {
        if (minion.automates && minion.automates.length > 0) {
          minion.automates.forEach(taskName => {
            const task = tasks.find(t => t.name === taskName);
            if (task && !task.completed && checkResources(task)) {
              const taskIndex = tasks.indexOf(task);
              if (taskIndex !== -1 && Math.random() < 0.01) { // 1% chance per frame
                startTask(taskIndex);
              }
            }
          });
        }
      });
    }
    
    function processResourceInteractions() {
      if (!resourceInteractions) return;
      
      resourceInteractions.forEach(interaction => {
        const source = resources[interaction.source];
        if (!source || !source.unlocked) return;
        
        if (interaction.type === "passiveGain") {
          const target = resources[interaction.target];
          if (target && target.unlocked) {
            const gain = source.value * interaction.amountPerUnit / 60;
            target.value = Math.min(target.max, target.value + gain);
          }
        } else if (interaction.type === "maxIncrease") {
          const target = resources[interaction.target];
          if (target && target.unlocked) {
            const increase = source.value * interaction.amountPerUnit;
            target.max = (target.baseMax || target.max) + increase;
          }
        }
      });
    }

    function updateStatus() {
      document.getElementById("status").innerText = statusMessage;
    }

    function updateLog() {
      document.getElementById("log").innerHTML = logMessages.join("<br>");
    }

    function updateResourcesDisplay() {
      document.getElementById("resources").innerHTML = Object.entries(resources)
        .filter(([key, resource]) => resource.unlocked)
        .map(([key, { value, max }]) => 
          `<div class="resource-item">${key.charAt(0).toUpperCase() + key.slice(1)}: <span>${Math.floor(value)}/${Math.floor(max)}</span></div>`
        ).join("");
    }

    function updateButtons() {
      debugLog("Updating buttons", 1156);
      tasks.forEach((task, index) => {
        let btn = buttons[index];
        if (btn) {
          if (task.completed && !task.repeatable) {
            btn.elt.disabled = true;
            btn.html(`${task.name} (Done)`);
            debugLog(`Button ${task.name} disabled (completed)`, 1163);
          } else {
            let isLocked = task.requires && !task.requires.every(req => 
              tasks.find(t => t.name === req).completed
            );
            let hasResources = checkResources(task);
            let hasCompletions = !task.maxCompletions || task.completionsThisLoop < task.maxCompletions;
            let isActiveTask = currentTask !== null;
            
            // Check if this is a SeedChoice and another has been made
            let isBlockedByExclusiveChoice = false;
            if (task.choiceGroup === "SeedChoice") {
              const otherSeedChoiceCompleted = tasks.some(t => 
                t.choiceGroup === "SeedChoice" && 
                t.name !== task.name && 
                t.completed
              );
              if (otherSeedChoiceCompleted) {
                isBlockedByExclusiveChoice = true;
                debugLog(`Button ${task.name} blocked by exclusive choice`, 1182);
              }
            }
            
            btn.elt.disabled = isLocked || !hasResources || !task.unlocked || isActiveTask || !hasCompletions || isBlockedByExclusiveChoice;
            btn.html(`Start ${task.name}`);
            debugLog(`Button ${task.name} enabled: ${!btn.elt.disabled}`, 1186);
          }
        }
      });
    }

    function checkStoryAutomation() {
      if (currentTask !== null) return;
      tasks.forEach((task, index) => {
        if (task.repeatable) return;
        if (!pathLog.automation[task.name]) return;
        if (task.completed) return;
        const requiresMet = !task.requires || task.requires.every(req => tasks.find(t => t.name === req).completed);
        const isUnlocked = task.unlocked || !task.unlockTask || tasks.some(t => t.name === task.unlockTask && t.completed);
        if (requiresMet && isUnlocked && checkResources(task)) {
          debugLog(`Automation starting ${task.name}`, 1201);
          startTask(index);
        }
      });
    }
  </script>
</body>
</html>