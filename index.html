<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Necromancer's Eternal Ascendancy</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.2/p5.min.js"></script>
  <link rel="stylesheet" href="styles.css">
</head>
<body>
  <div id="container">
    <div id="resource-panel">
      <div id="cog-button">⚙️</div>
      <h3>Resources</h3>
      <div id="resources"></div>
    </div>
    <div id="main-content">
      <div id="info">
        <h2>Necromancer's Eternal Ascendancy</h2>
        <p id="loop">Cycle: 1</p>
        <p id="notoriety">Notoriety: 0/100</p>
        <div id="notoriety-bar"><div id="notoriety-progress"></div></div>
        <p id="status">Begin your path to eternal dominion!</p>
      </div>
      <div id="board">
        <div id="task-list">
          <h3>Story Tasks</h3>
        </div>
        <div id="repeatable-task-list">
          <h3>Resource Tasks</h3>
        </div>
        <div id="upgrade-panel">
          <h3>Upgrades</h3>
        </div>
      </div>
      <div id="log"></div>
    </div>
  </div>
  <div id="options-modal">
    <div id="options-content">
      <h3>Options</h3>
      <div class="options-section">
        <div class="options-section-title">Display Settings</div>
        <div class="option-item">
          <label>
            <input type="checkbox" id="show-proficiency">
            Show Proficiency on Resource Tasks
          </label>
        </div>
        <div class="option-item">
          <label>
            <input type="checkbox" id="show-estimated-time">
            Show Estimated Time on Resource Tasks
          </label>
        </div>
      </div>
      <div class="options-section">
        <div class="options-section-title">Gameplay Settings</div>
        <div class="option-item">
          <label>
            <input type="checkbox" id="notoriety-task-mode">
            Notoriety: 1/sec during Tasks Only
          </label>
        </div>
      </div>
      <div class="options-section">
        <div class="options-section-title">Save Management</div>
        <button id="export-save">Export Save</button>
        <input type="file" id="import-save" accept=".json">
        <button id="wipe-save">Wipe Save</button>
      </div>
      <button id="close-modal">Close</button>
    </div>
  </div>
  <script src="data.js"></script>
  <script>
    let loopCount = 1;
    let currentTask = null;
    let taskProgress = 0;
    let statusMessage = "Begin your path to eternal dominion!";
    let buttons = [];
    let taskStartTime = 0;
    let logMessages = [];
    let lastSaveTime = 0;
    let settings = {
      showProficiency: true,
      showEstimatedTime: true,
      notorietyTaskMode: false
    };

    function setup() {
      noCanvas();
      loadGame();
      loadSettings();
      renderTaskList();
      renderUpgradeList();
      updateResourcesDisplay();
      setupOptionsModal();
    }

    function draw() {
      if (currentTask !== null) {
        taskProgress += 1 / 60;
        let task = tasks[currentTask];
        let progressPercent = (taskProgress / getTaskTime(task)) * 100;
        let progressBar = document.getElementById(`progress-${currentTask}`);
        if (progressBar) progressBar.style.width = `${progressPercent}%`;
        
        // Notoriety progression mode: 1 per second during tasks
        if (settings.notorietyTaskMode && resources.notoriety) {
          resources.notoriety.value = Math.min(100, resources.notoriety.value + (1 / 60));
          updateNotorietyDisplay();
        }
        
        if (taskProgress >= getTaskTime(task)) {
          completeTask();
        }
      }
      if (resources.notoriety && resources.notoriety.value >= 100) {
        endLoop();
      }
      if (frameCount % 600 === 0) { // Every 10 seconds
        saveGame();
      }
      updateResourcesDisplay();
      updateButtons();
      updateLog();
      updateStatus();
    }

    function saveGame() {
      const gameState = {
        resources,
        upgrades,
        tasks,
        loopCount,
        currentTask,
        taskProgress,
        logMessages,
        statusMessage,
        taskStartTime,
        settings
      };
      localStorage.setItem('necromancerGame', JSON.stringify(gameState));
      lastSaveTime = frameCount / 60;
    }

    function loadGame() {
      const savedGame = localStorage.getItem('necromancerGame');
      if (savedGame) {
        const gameState = JSON.parse(savedGame);
        // Merge saved resources with default to ensure notoriety exists
        resources = {
          mana: { value: 0, max: 100, unlocked: true },
          knowledge: { value: 0, max: 50, unlocked: false },
          notoriety: { value: 0, max: 100, unlocked: true }
        };
        if (gameState.resources) {
          for (let key in gameState.resources) {
            if (resources[key]) {
              resources[key] = { ...resources[key], ...gameState.resources[key] };
            }
          }
        }
        upgrades = gameState.upgrades || upgrades;
        tasks = gameState.tasks || tasks;
        // Ensure all repeatable tasks have autoRepeat and minimized properties
        tasks.forEach(task => {
          if (task.repeatable) {
            if (task.autoRepeat === undefined) {
              task.autoRepeat = false;
            }
            if (task.minimized === undefined) {
              task.minimized = false;
            }
          }
        });
        loopCount = gameState.loopCount || 1;
        currentTask = gameState.currentTask || null;
        taskProgress = gameState.taskProgress || 0;
        logMessages = gameState.logMessages || [];
        statusMessage = gameState.statusMessage || "Begin your path to eternal dominion!";
        taskStartTime = gameState.taskStartTime || 0;
        settings = gameState.settings || settings;
        updateLoopDisplay();
        updateNotorietyDisplay();
        updateLog();
        loadSettings();
      }
    }

    function loadSettings() {
      document.getElementById('show-proficiency').checked = settings.showProficiency;
      document.getElementById('show-estimated-time').checked = settings.showEstimatedTime;
      document.getElementById('notoriety-task-mode').checked = settings.notorietyTaskMode;
    }

    function setupOptionsModal() {
      const modal = document.getElementById('options-modal');
      const cogButton = document.getElementById('cog-button');
      const closeButton = document.getElementById('close-modal');
      const exportButton = document.getElementById('export-save');
      const importInput = document.getElementById('import-save');
      const wipeButton = document.getElementById('wipe-save');
      const showProficiencyCheck = document.getElementById('show-proficiency');
      const showEstimatedTimeCheck = document.getElementById('show-estimated-time');
      const notorietyTaskModeCheck = document.getElementById('notoriety-task-mode');

      loadSettings();

      showProficiencyCheck.addEventListener('change', (e) => {
        settings.showProficiency = e.target.checked;
        renderTaskList();
        saveGame();
      });

      showEstimatedTimeCheck.addEventListener('change', (e) => {
        settings.showEstimatedTime = e.target.checked;
        renderTaskList();
        saveGame();
      });

      notorietyTaskModeCheck.addEventListener('change', (e) => {
        settings.notorietyTaskMode = e.target.checked;
        saveGame();
      });

      const focusableElements = modal.querySelectorAll('button, input');
      const firstFocusable = focusableElements[0];
      const lastFocusable = focusableElements[focusableElements.length - 1];

      cogButton.addEventListener('click', () => {
        modal.style.display = 'flex';
        firstFocusable.focus();
      });

      closeButton.addEventListener('click', () => {
        modal.style.display = 'none';
      });

      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.style.display = 'none';
        }
      });

      modal.addEventListener('keydown', (e) => {
        if (e.key === 'Tab') {
          if (e.shiftKey) {
            if (document.activeElement === firstFocusable) {
              e.preventDefault();
              lastFocusable.focus();
            }
          } else {
            if (document.activeElement === lastFocusable) {
              e.preventDefault();
              firstFocusable.focus();
            }
          }
        }
        if (e.key === 'Escape') {
          modal.style.display = 'none';
        }
      });

      exportButton.addEventListener('click', () => {
              const gameState = {
                resources,
                upgrades,
                tasks,
                loopCount,
                currentTask,
                taskProgress,
                logMessages,
                statusMessage,
                taskStartTime,
                settings
              };
        const blob = new Blob([JSON.stringify(gameState, null, 2)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'savegame.json';
        a.click();
        URL.revokeObjectURL(url);
      });

      importInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (event) => {
            try {
              const gameState = JSON.parse(event.target.result);
              if (!gameState.resources || !gameState.upgrades || !gameState.tasks ||
                  !gameState.loopCount || !gameState.logMessages ||
                  !gameState.statusMessage || !gameState.taskStartTime) {
                throw new Error('Invalid save file structure');
              }
              // Merge saved resources with default
              resources = {
                mana: { value: 0, max: 100, unlocked: true },
                knowledge: { value: 0, max: 50, unlocked: false },
                notoriety: { value: 0, max: 100, unlocked: true }
              };
              for (let key in gameState.resources) {
                if (resources[key]) {
                  resources[key] = { ...resources[key], ...gameState.resources[key] };
                }
              }
              upgrades = gameState.upgrades;
              tasks = gameState.tasks;
              loopCount = gameState.loopCount;
              currentTask = gameState.currentTask;
              taskProgress = gameState.taskProgress;
              logMessages = gameState.logMessages;
              statusMessage = gameState.statusMessage;
              taskStartTime = gameState.taskStartTime;
              settings = gameState.settings || settings;
              saveGame();
              loadSettings();
              renderTaskList();
              renderUpgradeList();
              updateResourcesDisplay();
              updateLoopDisplay();
              updateNotorietyDisplay();
              updateLog();
              modal.style.display = 'none';
            } catch (error) {
              alert('Invalid save file: ' + error.message);
            }
          };
          reader.readAsText(file);
        }
      });

      wipeButton.addEventListener('click', () => {
        if (confirm('Are you sure you want to wipe your save?')) {
          localStorage.removeItem('necromancerGame');
          location.reload();
        }
      });
    }

    function renderTaskList() {
      let taskList = document.getElementById("task-list");
      let repeatableTaskList = document.getElementById("repeatable-task-list");
      taskList.innerHTML = "<h3>Story Tasks</h3>";
      repeatableTaskList.innerHTML = "<h3>Resource Tasks</h3>";
      buttons = [];
      tasks.forEach((task, index) => {
        if (!task.unlocked && task.unlockTask) {
          task.unlocked = tasks.some(t => t.name === task.unlockTask && t.completed);
        }
        let isVisible = task.repeatable ? 
          (task.unlocked || !task.unlockTask) : 
          (!task.completed && (!task.requires || task.requires.every(req => 
            tasks.find(t => t.name === req).completed
          )));
        if (isVisible) {
          let isLocked = task.requires && !task.requires.every(req => 
            tasks.find(t => t.name === req).completed
          );
          let hasResources = checkResources(task);
          let hasCompletions = !task.maxCompletions || task.completionsThisLoop < task.maxCompletions;
          let card = document.createElement("div");
          let cardClasses = `task-card ${isLocked ? "locked" : ""} ${task.repeatable ? "repeatable" : ""} ${task.safe ? "safe" : ""}`;
          // Only apply minimized class to repeatable tasks
          if (task.repeatable && task.minimized) {
            cardClasses += " minimized";
          }
          card.className = cardClasses;
          let adjustedCost = task.cost ? Object.entries(task.cost).reduce((acc, [k, v]) => {
            let cost = v;
            if (k === "mana" && upgrades.manaEfficiency.level > 0) {
              cost *= (1 - 0.1 * upgrades.manaEfficiency.level);
            }
            if (upgrades.nihilisticResolve.level > 0) {
              cost *= (1 - 0.05 * upgrades.nihilisticResolve.level);
            }
            acc[k] = Math.ceil(cost);
            return acc;
          }, {}) : {};
          let costText = task.cost ? `Cost: ${Object.entries(adjustedCost).map(([k, v]) => `${k}: ${v}`).join(", ")}` : "";
          let yieldsText = task.yields ? `Yields: ${Object.entries(task.yields).map(([k, v]) => `${k}: ${v}`).join(", ")}` : "";
          let notorietyText = task.notorietyCost ? `Notoriety: ${task.notorietyCost > 0 ? "+" : ""}${task.notorietyCost}` : "";
          let proficiencyText = "";
          if (task.repeatable) {
            if (settings.showProficiency) {
              proficiencyText = `<div>Proficiency: ${task.proficiency}</div>`;
            }
          } else {
            proficiencyText = `<div>Proficiency: ${task.proficiency}</div>`;
          }
          let estimatedTimeText = "";
          if (task.repeatable && settings.showEstimatedTime) {
            let estimatedTime = getTaskTime(task);
            estimatedTimeText = `<div>Time: ~${estimatedTime.toFixed(1)}s</div>`;
          }
          let autoRepeatToggle = "";
          let minimizeButton = "";
          if (task.repeatable) {
            autoRepeatToggle = `
              <div class="auto-repeat-toggle">
                <label>
                  <input type="checkbox" class="auto-repeat-checkbox" data-task-index="${index}" ${task.autoRepeat ? 'checked' : ''}>
                  Auto Repeat
                </label>
              </div>
            `;
            let minimizeSymbol = task.minimized ? "+" : "−";
            minimizeButton = `<button class="minimize-button" data-task-index="${index}">${minimizeSymbol}</button>`;
          }
          let taskContent = `
            <div class="task-content">
              <div>${task.description}</div>
              ${proficiencyText}
              ${estimatedTimeText}
              ${costText ? `<div>${costText}</div>` : ""}
              ${yieldsText ? `<div>${yieldsText}</div>` : ""}
              ${notorietyText ? `<div>${notorietyText}</div>` : ""}
              ${task.maxCompletions ? `<div>Uses left: ${task.maxCompletions - task.completionsThisLoop}/${task.maxCompletions}</div>` : ""}
              ${autoRepeatToggle}
              <div class="progress-bar"><div class="progress" id="progress-${index}"></div></div>
            </div>
          `;
          // For story tasks (non-repeatable), always show content. For resource tasks, check minimized state
          let shouldShowContent = !task.repeatable || !task.minimized;
          card.innerHTML = `
            <div class="task-header">
              <div class="task-name">${task.name}</div>
              ${minimizeButton}
            </div>
            ${shouldShowContent ? taskContent : ""}
          `;
          if (!isLocked && (task.unlocked || !task.unlockTask) && hasCompletions) {
            // Only show start button if task is not minimized (only applies to repeatable tasks)
            let shouldShowButton = !task.repeatable || !task.minimized;
            if (shouldShowButton) {
              let btn = createButton(`Start ${task.name}`);
              btn.elt.style.marginTop = "8px";
              btn.elt.id = `button-${index}`;
              btn.elt.disabled = !hasResources || currentTask !== null || !hasCompletions;
              btn.mousePressed(() => startTask(index));
              btn.parent(card);
            }
            
            // Add event listener for auto-repeat toggle (only for repeatable tasks)
            if (task.repeatable) {
              let checkbox = card.querySelector('.auto-repeat-checkbox');
              if (checkbox) {
                checkbox.addEventListener('change', (e) => {
                  tasks[index].autoRepeat = e.target.checked;
                  saveGame();
                });
              }
              
              // Add event listener for minimize button (only for repeatable tasks)
              let minimizeBtn = card.querySelector('.minimize-button');
              if (minimizeBtn) {
                minimizeBtn.addEventListener('click', (e) => {
                  e.stopPropagation();
                  // Only toggle minimized state for repeatable tasks
                  if (tasks[index].repeatable) {
                    tasks[index].minimized = !tasks[index].minimized;
                    renderTaskList();
                    saveGame();
                  }
                });
              }
            }
            
            // Add resource/completion warnings only if content is visible
            if (shouldShowContent) {
              if (!hasResources) {
                let contentDiv = card.querySelector('.task-content');
                if (contentDiv) {
                  contentDiv.innerHTML += `<div>Insufficient resources: ${costText}</div>`;
                }
              }
              if (!hasCompletions) {
                let contentDiv = card.querySelector('.task-content');
                if (contentDiv) {
                  contentDiv.innerHTML += `<div>No uses left this cycle</div>`;
                }
              }
            }
            
            // Update progress bar if task is active
            if (currentTask === index) {
              let progressBar = document.getElementById(`progress-${index}`);
              if (progressBar) {
                let progressPercent = (taskProgress / getTaskTime(task)) * 100;
                progressBar.style.width = `${progressPercent}%`;
              }
            }
          } else {
            let lockReason = isLocked ? `Requires: ${task.requires.join(", ")}` : 
                           !task.unlocked ? `Locked: Complete ${task.unlockTask}` : 
                           !hasCompletions ? "No uses left this cycle" : 
                           `Insufficient resources: ${costText}`;
            card.innerHTML += `<div>${lockReason}</div>`;
          }
          if (task.repeatable) {
            repeatableTaskList.appendChild(card);
          } else {
            taskList.appendChild(card);
          }
        }
      });
    }

    function renderUpgradeList() {
      let upgradePanel = document.getElementById("upgrade-panel");
      upgradePanel.innerHTML = "<h3>Upgrades</h3>";
      Object.entries(upgrades).forEach(([key, upgrade]) => {
        if (!upgrade.unlocked) {
          upgrade.unlocked = tasks.some(t => t.name === upgrade.unlockTask && t.completed);
        }
        if (upgrade.unlocked) {
          let canAfford = checkResources({ cost: upgrade.cost });
          let isMaxed = upgrade.level >= upgrade.maxLevel;
          let adjustedCost = {};
          for (let [resource, amount] of Object.entries(upgrade.cost)) {
            let cost = amount;
            if (resource === "mana" && upgrades.manaEfficiency.level > 0) {
              cost *= (1 - 0.1 * upgrades.manaEfficiency.level);
            }
            if (upgrades.nihilisticResolve.level > 0) {
              cost *= (1 - 0.05 * upgrades.nihilisticResolve.level);
            }
            adjustedCost[resource] = Math.ceil(cost);
          }
          let costText = `Cost: ${Object.entries(adjustedCost).map(([k, v]) => `${k}: ${v}`).join(", ")}`;
          let card = document.createElement("div");
          card.className = `upgrade-card ${!canAfford || isMaxed ? "locked" : ""}`;
          card.innerHTML = `
            <div class="upgrade-name">${key.replace(/([A-Z])/g, ' $1').trim()}</div>
            <div>${upgrade.description}</div>
            <div>Level: ${upgrade.level}/${upgrade.maxLevel}</div>
            <div>${costText}</div>
          `;
          if (!isMaxed && canAfford) {
            let btn = createButton("Buy");
            btn.elt.style.marginTop = "5px";
            btn.mousePressed(() => purchaseUpgrade(key));
            btn.parent(card);
          } else {
            card.innerHTML += `<div>${isMaxed ? "Max level reached" : "Insufficient resources"}</div>`;
          }
          upgradePanel.appendChild(card);
        }
      });
    }

    function startTask(index) {
      if (currentTask === null && (!tasks[index].completed || tasks[index].repeatable)) {
        let task = tasks[index];
        let isLocked = task.requires && !task.requires.every(req => 
          tasks.find(t => t.name === req).completed
        );
        let hasResources = checkResources(task);
        let hasCompletions = !task.maxCompletions || task.completionsThisLoop < task.maxCompletions;
        if (!isLocked && hasResources && (task.unlocked || !task.unlockTask) && hasCompletions) {
          task.isActive = true;
          currentTask = index;
          taskProgress = 0;
          taskStartTime = frameCount / 60;
          statusMessage = `Performing ${task.name}...`;
          if (task.cost) {
            for (let [resource, amount] of Object.entries(task.cost)) {
              resources[resource].value -= amount;
            }
          }
          // Immediately update all displays when task starts
          updateResourcesDisplay();
          renderTaskList();
          renderUpgradeList();
          updateButtons();
          saveGame();
        }
      }
    }

    function completeTask() {
      let task = tasks[currentTask];
      let completionTime = (frameCount / 60 - taskStartTime).toFixed(2);
      task.proficiency++;
      task.isActive = false;
      if (!task.repeatable) {
        task.completed = true;
        if (task.resourceMaxIncrease) {
          for (let [resource, amount] of Object.entries(task.resourceMaxIncrease)) {
            resources[resource].max += amount;
            resources[resource].unlocked = true;
          }
        }
        if (task.name === "Survive Plague") {
          resources.knowledge.unlocked = true;
          resources.knowledge.value = Math.min(resources.knowledge.value + 3, resources.knowledge.max);
        }
      }
      if (task.maxCompletions) {
        task.completionsThisLoop++;
      }
      if (task.yields) {
        for (let [resource, amount] of Object.entries(task.yields)) {
          let adjustedAmount = amount;
          if (resource === "knowledge" && upgrades.knowledgeBoost.level > 0) {
            adjustedAmount += upgrades.knowledgeBoost.level;
          }
          resources[resource].value = Math.min(
            resources[resource].value + adjustedAmount,
            resources[resource].max
          );
          resources[resource].unlocked = true;
        }
        updateResourcesDisplay();
      }
      if (task.notorietyCost && !task.safe && !settings.notorietyTaskMode) {
        resources.notoriety.value = Math.max(0, Math.min(100, resources.notoriety.value + task.notorietyCost));
        updateNotorietyDisplay();
      }
      tasks.forEach(t => {
        if (t.unlockTask === task.name) t.unlocked = true;
      });
      statusMessage = `${task.name} completed!`;
      logMessages.unshift(`${task.name} completed in ${completionTime}s`);
      if (logMessages.length > 10) logMessages.pop();
      updateLog();
      currentTask = null;
      taskProgress = 0;
      renderTaskList();
      renderUpgradeList();
      saveGame();
      if (tasks.filter(t => !t.repeatable).every(t => t.completed)) {
        statusMessage = "Knowledge amassed! Choose your path to power.";
      }
      
      // Auto-repeat for repeatable tasks (per-task setting)
      if (task.repeatable && task.autoRepeat) {
        let taskIndex = tasks.findIndex(t => t.name === task.name);
        if (taskIndex !== -1) {
          let repeatTask = tasks[taskIndex];
          let hasResources = checkResources(repeatTask);
          let hasCompletions = !repeatTask.maxCompletions || repeatTask.completionsThisLoop < repeatTask.maxCompletions;
          if (hasResources && hasCompletions && (repeatTask.unlocked || !repeatTask.unlockTask)) {
            // Small delay to allow UI to update
            setTimeout(() => {
              startTask(taskIndex);
            }, 100);
          }
        }
      }
    }

    function purchaseUpgrade(key) {
      let upgrade = upgrades[key];
      if (upgrade.level < upgrade.maxLevel && checkResources({ cost: upgrade.cost })) {
        for (let [resource, amount] of Object.entries(upgrade.cost)) {
          resources[resource].value -= amount;
        }
        upgrade.level++;
        statusMessage = `${key.replace(/([A-Z])/g, ' $1').trim()} upgraded to level ${upgrade.level}!`;
        logMessages.unshift(statusMessage);
        if (logMessages.length > 10) logMessages.pop();
        updateLog();
        updateResourcesDisplay();
        renderUpgradeList();
        renderTaskList();
        saveGame();
      }
    }

    function checkResources(task) {
      if (!task.cost) return true;
      let adjustedCost = {};
      for (let [resource, amount] of Object.entries(task.cost)) {
        let cost = amount;
        if (resource === "mana" && upgrades.manaEfficiency.level > 0) {
          cost *= (1 - 0.1 * upgrades.manaEfficiency.level);
        }
        if (upgrades.nihilisticResolve.level > 0) {
          cost *= (1 - 0.05 * upgrades.nihilisticResolve.level);
        }
        adjustedCost[resource] = Math.ceil(cost);
      }
      return Object.entries(adjustedCost).every(([resource, amount]) => resources[resource].value >= amount);
    }

    function getTaskTime(task) {
      let time = task.baseTime * (1 - task.proficiency * 0.1);
      if (upgrades.swiftRituals.level > 0) {
        time *= (1 - 0.1 * upgrades.swiftRituals.level);
      }
      if (upgrades.crowFamiliar.level > 0) {
        time *= (1 - 0.05 * upgrades.crowFamiliar.level);
      }
      return Math.max(1, time);
    }

    function endLoop() {
      loopCount++;
      resources.notoriety.value = 0;
      currentTask = null;
      taskProgress = 0;
      for (let task of tasks) {
        task.isActive = false;
        if (!task.repeatable) {
          task.completed = false;
        }
        if (task.maxCompletions) {
          task.completionsThisLoop = 0;
        }
      }
      for (let key in upgrades) {
        upgrades[key].level = 0;
      }
      statusMessage = "Notoriety discovered! Time loop resets with greater mastery.";
      logMessages.unshift(`Cycle ${loopCount - 1} ended. Loop reset.`);
      if (logMessages.length > 10) logMessages.pop();
      updateLog();
      updateLoopDisplay();
      updateNotorietyDisplay();
      renderTaskList();
      renderUpgradeList();
      saveGame();
    }

    function updateLoopDisplay() {
      document.getElementById("loop").innerText = `Cycle: ${loopCount}`;
    }

    function updateNotorietyDisplay() {
      if (resources.notoriety) {
        document.getElementById("notoriety").innerText = `Notoriety: ${Math.floor(resources.notoriety.value)}/100`;
        document.getElementById("notoriety-progress").style.width = `${Math.max(0, Math.min(100, (resources.notoriety.value / 100) * 100))}%`;
      }
    }

    function updateStatus() {
      document.getElementById("status").innerText = statusMessage;
    }

    function updateLog() {
      document.getElementById("log").innerHTML = logMessages.join("<br>");
    }

    function updateResourcesDisplay() {
      document.getElementById("resources").innerHTML = Object.entries(resources)
        .filter(([key, resource]) => resource.unlocked)
        .map(([key, { value, max }]) => 
          `<div class="resource-item">${key.charAt(0).toUpperCase() + key.slice(1)}: <span>${Math.floor(value)}/${Math.floor(max)}</span></div>`
        ).join("");
    }

    function updateButtons() {
      tasks.forEach((task, index) => {
        let btn = buttons[index];
        if (btn) {
          if (task.completed && !task.repeatable) {
            btn.elt.disabled = true;
            btn.html(`${task.name} (Done)`);
          } else {
            let isLocked = task.requires && !task.requires.every(req => 
              tasks.find(t => t.name === req).completed
            );
            let hasResources = checkResources(task);
            let hasCompletions = !task.maxCompletions || task.completionsThisLoop < task.maxCompletions;
            let isActiveTask = currentTask !== null;
            btn.elt.disabled = isLocked || !hasResources || !task.unlocked || isActiveTask || !hasCompletions;
            btn.html(`Start ${task.name}`);
          }
        }
      });
    }
  </script>
</body>
</html>
